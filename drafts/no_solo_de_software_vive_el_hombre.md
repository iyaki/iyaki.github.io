# No solo de software vive el hombre

Usar las herramientas adecuadas para el trabajo adecuado, saber utilizarlas y darles el mantenimiento necesario para que sigan funcionando son formas importantes de aumentar nuestra productividad. Pero existe algo con un impacto mucho m√°s profundo y de mayor magnitud: Tomar las decisiones que m√°s nos acercar√°n a nuestros resultados deseados. Porque uno puede ser extremadamente r√°pido para construir un auto, pero si lo que se necesitaba era un barco, de poco servir√° todo el esfuerzo que se invierta.

En este aspecto hay dos puntos elementales que nos ayudar√°n a alcanzar el mayor impacto posible mediante nuestro trabajo.

El primero es conocer cu√°l es el resultado deseado, en este sentido, por lo general, cuanto m√°s contexto e informaci√≥n tengamos sobre el problema que buscamos solucionar, mejor preparados estaremos para brindar una soluci√≥n.

El segundo aspecto relevante es poder predecir, de la manera m√°s acertada posible, las consecuencias de nuestras acciones. Para esto podemos optar por opciones poco ortodoxas como el tarot, la bola de cristal o la lectura de la borra del caf√©; o centrarnos en aprovechar lo que otros han estudiado al respecto en el pasado y sus conclusiones. Conclusiones que en muchos casos se han recopilado en leyes, teor√≠as y principios ampliamente conocidos en el √°mbito de la gesti√≥n y la tecnolog√≠a.

En este art√≠culo nos centraremos en estas √∫ltimas.

Por eso hoy, les dejo un breve resumen de las que considero m√°s √∫tiles a la hora de avanzar sobre un proyecto como colaborador individual o como parte de su management.

## Principio de Pareto o Regla del 80/20

Durante el siglo XIX el economista italiano Vilfredo Pareto observ√≥ que *aproximadamente el 80% de los efectos proviene del 20% de las causas*.

En el contexto de proyectos de software, este principio cobra una relevancia significativa. Al aplicarlo, nos damos cuenta de que el 80% del valor agregado proviene del 20% de las caracter√≠sticas o funcionalidades implementadas.

Y entonces, ¬øpor qu√© esto es tan relevante para nosotros?

Porque nos ayuda a priorizar.

Si sabemos qu√© peque√±a parte de nuestro trabajo es responsable de la mayor√≠a de los resultados, podemos concentrarnos en eso primero.

Ya sea que estemos trabajando en solitario o en equipo, el Principio de Pareto nos da una hoja de ruta inteligente para maximizar nuestra eficiencia y lograr mejores resultados.

## Carga cognitiva

La carga cognitiva no es un principio como tal, pero s√≠ un concepto que, si tenemos en cuenta, puede ayudarnos a nosotros y a nuestros compa√±eros a obtener mejores resultados.

La carga cognitiva *se refiere a la cantidad de esfuerzo mental requerido para realizar una tarea o procesar informaci√≥n*.

Imaginemos que estamos trabajando en un proyecto de software y debemos recordar todos los detalles sobre c√≥mo funciona cada parte del c√≥digo que se est√° escribiendo. Bueno, esa es la carga cognitiva en acci√≥n. Cuanto m√°s complicado sea el proyecto, m√°s trabajo mental habr√° que hacer para mantener todo en orden.

A la hora de programar existen m√∫ltiples maneras de disminuir la carga cognitiva que una pieza de c√≥digo fuente requiere. A m√≠, en particular, me agradan bastante las sugerencias de [*Object Calisthenics*](https://franiglesias.github.io/calisthenics-1/).

## Context Switching

Otro concepto que, a pesar de no tratarse de una ley o principio, puede impactar significativamente en nuestra productividad.  
Context switching *se refiere al proceso de cambiar nuestra atenci√≥n y enfoque de una tarea a otra*. Este cambio constante de contexto puede ser perjudicial para nuestra productividad, ya que requerimos tiempo y energ√≠a para ajustarnos a la nueva tarea.

Y peor a√∫n, aunque la interrupci√≥n fuese breve, volver a [‚Äúla zona‚Äù](https://www.kenneth-truyers.net/2015/10/05/programming-in-the-zone/) o [‚Äúel flujo‚Äù](https://github.blog/2024-01-22-how-to-get-in-the-flow-while-coding-and-why-its-important/) puede tomarnos [hasta 15 minutos](https://contextkeeper.io/blog/the-real-cost-of-an-interruption-and-context-switching/).

## Principio de parsimonia o Navaja de Ockham

El Principio de Parsimonia, tambi√©n conocido como la Navaja de Ockham, es un principio filos√≥fico que sugiere que, *entre varias explicaciones posibles para un fen√≥meno, la m√°s simple suele ser la correcta*. Este principio, propuesto por el fil√≥sofo y te√≥logo Guillermo de Ockham en el siglo XIV, aboga por no multiplicar las entidades innecesariamente.

Entonces, en el mundo del desarrollo de software, esto significa que cuando nos encontramos con un problema a resolver (un bug, una nueva funcionalidad a implementar, un desaf√≠o a nivel de arquitectura, etc.), deber√≠amos intentar encontrar la soluci√≥n m√°s sencilla posible. En lugar de enredarnos con soluciones complejas que pueden generar m√°s problemas, deber√≠amos seguir el camino m√°s simple y directo.

Dentro del mundo de la programaci√≥n, esto se encuentra tambi√©n muy relacionado con los principios [YAGNI](https://enterprisecraftsmanship.com/posts/yagni-revisited/) y [KISS](https://enterprisecraftsmanship.com/posts/kiss-revisited/).

## Ley de Conway

La Ley de Conway viene a recordarnos lo importante que es la comunicaci√≥n en el desarrollo de software, formulada por el programador Melvin Conway en 1968, establece que *las organizaciones que dise√±an sistemas est√°n inevitablemente limitadas a producir dise√±os que sean r√©plicas de la estructura de comunicaci√≥n de sus propias organizaciones*.

He visto muchas veces art√≠culos y explicaciones que se centran en c√≥mo un equipo con poca organizaci√≥n y falta de comunicaci√≥n producir√° software de baja calidad y que, probablemente, no resuelva necesidades reales. Pero a m√≠ me resulta mucho m√°s interesante tener en cuenta esta ley a la hora de dise√±ar sistemas y definir su arquitectura.

El impacto de la ley de Conway en la arquitectura de software es muy significativo y es algo que he podido comprobar de primera mano. Hace algunos a√±os y en medio del hype por los microservicios, en la empresa donde trabajaba, nos propusimos a, para sorpresa de nadie, migrar a una arquitectura de microservicios. Los beneficios de esta arquitectura son bien conocidos, y entre ellos destacan:

1. Mejor tolerancia a fallos, al facilitar desacoplar los servicios, permitiendo que una pieza de software fall√© sin afectar a las dem√°s.
2. Agnosticismo tecnol√≥gico, cada microservicio puede desarrollarse con las tecnolog√≠as que considere m√°s apropiadas para lograr su cometido.
3. Mayor independencia a la hora de evolucionar y desplegar cada servicio al poder hacerlo de manera individual.
4. Reusabilidad entre √°reas de negocio, si partes de la l√≥gica de negocio se repiten entre distintos procesos y √°reas, es posible reutilizar los servicios ya desarrollados.
5. Permite la experimentaci√≥n y la evoluci√≥n r√°pida, al poder ser desarrollados sin comprometer al resto del sistema.

Pero nunca llegamos a beneficiarnos de ellos y es que:

1. Nuestras reglas de negocio, aunque bien definidas, eran bastante complejas y la forma en que el equipo las concibe hace que est√©n fuertemente acopladas entre s√≠; por lo que, incluso desarrollando diferentes aplicativos, el nivel de dependencia entre ellos imped√≠a una mayor resiliencia ante fallos de un componente.
2. Todo nuestro equipo ‚Äúhablaba‚Äù los mismos lenguajes de programaci√≥n, por lo que las posibles tecnolog√≠as a utilizar eran bastante limitadas.
3. Al haber dependencias tan fuertes entre las distintas reglas de negocio, cualquier cambio terminaba afectando m√∫ltiples componentes.
4. Nuestras reglas de negocio, aunque complejas, se manten√≠an dentro de un alcance bastante acotado, por lo que la reutilizaci√≥n de servicios era muy poco probable.
5. Al tener un equipo conformado, principalmente, por desarrolladores Junior, la experimentaci√≥n resultaba casi nula.

Y, para empeorar, las cosas, los integrantes del equipo siempre hab√≠a trabajado de manera muy cercana entre ellos, por lo que no exist√≠a un ownership claro sobre procesos o m√≥dulos que permitieran la independencia necesaria para desacoplar las distintas piezas de software. Resultando en que los intentos de separar servicios y comunicarlos solo generara confusi√≥n y frustraci√≥n.

Este es un claro ejemplo de c√≥mo un equipo que ten√≠a la capacidad t√©cnica para desarrollar microservicios fall√≥ en hacerlo por razones meramente organizativas y comunicacionales.  
Para poder implementar exitosamente una arquitectura de microservicios, primero deber√≠amos haber comenzado por cambiar la forma en que trabaj√°bamos. Armar m√∫ltiples equipos con un alcance y objetivos claros, capacitar a los desarrolladores en algunas tecnolog√≠as nuevas, probablemente contratar m√°s colaboradores, etc.

Por suerte, esta migraci√≥n fue lanzada como una prueba piloto, y notamos todos estas fricciones antes de que se volvieran un problema. As√≠, de com√∫n acuerdo con el resto del equipo, decidimos volver al esquema monol√≠tico con el que trabaj√°bamos hasta entonces y centrar nuestros esfuerzos en mejorar la estructura y modularidad de nuestra aplicaci√≥n, en lugar de intentar separar todo de manera artificial y forzada en distintos servicios independientes.

## Ley de Parkinson

En 1957 Cyril Northcote Parkinson enunci√≥: *el trabajo se expande hasta llenar el tiempo disponible para que se termine*.

Al realizar la gesti√≥n de un proyecto, ya sea como colaboradores individuales, estimando tareas que deber√°n realizarse o realizando planificaciones de alto nivel, como Project Manager, siempre es buena idea tener en cuenta esta ley.  
Seg√∫n nos advierte, aumentar ‚Äúpor las dudas‚Äù el tiempo que se planifica para dedicar a una cierta tarea puede no ser la mejor idea, ya que terminaremos consumiendo ese tiempo en detalles superfluos y probablemente innecesarios (este es un buen punto en el que aplicar el Principio de Pareto para decidir cuando detenerse) en lugar de aprovechar ese tiempo en adelantar otras tareas que puedan aportar un mayor valor real.

## Ley de Brooks

Fred Brooks, en su libro ‚ÄúThe Mythical Man-Month‚Äù publicado en 1975, afirma: *a√±adir m√°s efectivos a un proyecto de software en retraso, lo retrasar√° m√°s*.

Esta es especialmente relevante para los roles de Management y Liderazgo en proyectos de desarrollo de software, ya que anta√±o era una pr√°ctica muy normal el intentar resolver los problemas de un proyecto mediante la adici√≥n de m√°s y m√°s colaboradores.

El problema es que, lejos de de generar resultados m√°s velozmente, se produce el efecto contrario; donde la entrega de valor se retrasa a√∫n m√°s, debido a que la comunicaci√≥n se complejiza de manera exponencial a medida que se agregan personas y se requiere tiempo adicional para capacitar a estas nuevas incorporaciones y transferirles todo el contexto necesario.

## Ley de Hofstadter

Esta ley describe la dificultad de estimar el tiempo que llevar√° completar tareas de gran complejidad acu√±ada por Douglas Hofstadter en su libro ‚ÄúG√∂del, Escher, Bach: un Eterno y Gr√°cil Bucle‚Äù afirma: *Siempre nos lleva m√°s tiempo de lo esperado, incluso teniendo en cuenta la ley de Hofstadter*.

Sobre esta creo que no hay mucho que agregar, pero conocerla es una buena forma de recordar que la estimaci√≥n de tareas siempre cuenta con su cuota de incertidumbre.

## Teor√≠a de las ventanas rotas

Esta teor√≠a proviene de la criminolog√≠a. Introducida en un art√≠culo de 1982 por los cient√≠ficos sociales James Q. Wilson y George L. Kelling y popularizada en la d√©cada de 1990, sostiene que los signos visibles de la delincuencia, el comportamiento antisocial y los disturbios civiles crean un entorno urbano que fomenta la delincuencia y el desorden, incluidos los delitos graves; sugiriendo que los m√©todos policiales que se centran en atacar los delitos menores, como el vandalismo, la vagancia, el consumo de alcohol en p√∫blico, el cruce incorrecto de peatones y la evasi√≥n de tarifas, ayudan a crear una atm√≥sfera de orden y legalidad.

Esta idea es portada en 1999 al √°mbito de la programaci√≥n por Andy Hunt y Dave Thomas en su libro ‚ÄúThe Pragmatic Programmer‚Äù, donde aplican el concepto de las ventanas rotas a la calidad de software.

En su libro, sugieren nunca dejas las ‚Äúventanas rotas‚Äù sin arreglar y repararlas en cuanto se las identifica. Evitando as√≠ esparcir malas pr√°cticas al resto del c√≥digo fuente.

Considero esto particularmente importante cuando un equipo cuenta con una gran cantidad de desarrolladores Junior, ya que es mediante el mismo c√≥digo fuente sobre el que est√°n trabajando que, d√≠a a d√≠a, siguen aprendiendo c√≥mo programar. Sin embargo al ser una pr√°ctica que depende en gran medida de la cultura del equipo (y del √°rea o la empresa donde est√© trabajando ese equipo) puede ser un desaf√≠o notable implementar pr√°cticas que fomenten la reparaci√≥n constante de estas ‚Äúventanas rotas‚Äù.

## Principio de Hanlon

El Principio de Hanlon (o navaja de Hanlon) no trata de manera directa sobre productividad pero es una herramienta que puede ayudarnos a lograr mejores resultados cuando se trabaja en conjunto.

Este principio establece: *Nunca atribuyas a la maldad lo que se explica adecuadamente por la estupidez*.

Me gusta porque es simple y pragm√°tico, y nos invita a darle a las personas el beneficio de la duda. Record√°ndonos que muchas veces un conflicto que estemos teniendo con otras personas puede ser producto, simplemente, de un malentendido.

## Redondeando

Esas fueron la leyes, principios y conceptos que, a mi parecer, resultan mas √∫tiles a la hora de participar en un proyecto software.

Espero que les puedan ser de utilidad tambi√©n a ustedes.

Si quieren charlar sobre este o cualquier otro tema siempre pueden contactarme via e-mail o dejar un comentario (Me olvid√© de avisar eso! Ahora hay una secci√≥n de comentarios al final de los posts üòÅ).

–î–æ –ø–æ–±–∞—á–µ–Ω—ñ—è!
